{
    "title": "Overview of Lifecycles",
    "image": "assets/blogs/blog-3.png",
    "content": "**Understanding Script Execution in Lens Studio**\n\nThis is part three of the **Behind the Scenes of Lens Studio** series. Now that you’ve seen how the show flows and how everything is organized on stage, Script Execution reveals how each cue and action plays out moment by moment to keep the performance running.\n\nI designed this diagram to make the script lifecycle easier to grasp—because without a visual, it’s easy to lose track of the sequence. Think of the script lifecycle like a rehearsal schedule: the cast arrives, gets ready, takes their places, and then performs again and again, every frame.\n\n**Script Load**\n\nThis is when the cast first walks into the theater. The script arrives, values are introduced, but the set isn’t built yet—no scene objects are guaranteed. It’s the perfect moment to define global variables and lay down the groundwork before anything is visible.\n\n```javascript\n// script load\nvar speed = 3.0;\nvar isActive = false;\n```\n\n**onAwake()**\n\nHere, the crew prepares the props and sets initial positions before the audience arrives. You set up default values, disable indicators, or capture starting positions—quiet backstage work.\n\n```javascript\n// onAwake\nscript.myIndicator.enabled = false;\nscript.startPosition = script.object.getTransform().getWorldPosition();\n```\n\n**onStart()**\n\nNow the stage lights come on and the actors can see each other. All scene objects are available, so you can reference meshes, positions, or states you couldn’t touch earlier.\n\n```javascript\n// onStart\nscript.target = script.getSceneObject(\"TargetObject\");\nscript.initialScale = script.target.getTransform().getLocalScale();\n```\n\n**onUpdate()**\n\nThis is the live performance—running 30–60 times per second. Actors move, respond, adjust, and react. Each frame is a new beat where you animate objects, apply transforms, or handle tracking data.\n\n```javascript\n// onUpdate\nvar dt = getDeltaTime();\nvar currentPos = script.object.getTransform().getWorldPosition();\nvar nextPos = currentPos.add(new vec3(0, speed * dt, 0));\nscript.object.getTransform().setWorldPosition(nextPos);\n```\n\n**Events**\n\nNot all performances run linearly—sometimes the director calls for improvisation. Events trigger outside the main loop, adding interactivity and timing.\n\n**Touch Events** — audience interaction cues.\n```javascript\n// onTouchStarted\nscript.api.onTouchStarted = function(eventData) {\n    isActive = true;\n    script.myIndicator.enabled = true;\n};\n```\n\n**Custom Events** — directors sending signals to specific actors.\n```javascript\nscript.api.triggerPulse = function() {\n    global.events.broadcast(\"PulseEvent\");\n};\n\nglobal.events.add(\"PulseEvent\", function() {\n    script.object.getTransform().setLocalScale(script.initialScale.uniformScale(1.3));\n});\n```\n\n**Timers / Tweens** — scheduled cues that fire after a delay.\n```javascript\nscript.createEvent(\"DelayedCallbackEvent\").bind(function() {\n    script.myIndicator.enabled = false;\n});\n```\n\nAll of these cues—touch gestures, broadcasts, timers—feed into the overall performance. Each frame completes like a scene in a play, then the cycle loops back to `onUpdate()`, keeping the experience continuous and responsive.\n\n**Why it Matters**\n\nMisunderstanding the lifecycle is like mixing up call times for your cast—actors show up late, props appear early, and the show feels unpredictable. Once you understand how each cue fits into the sequence, your scripts become more reliable, intentional, and easier to debug.\n"
}